# Задачи по книге 

Упражнения Глава 1. Знакомство с алгоритмами

1.1 Имеется отсортированный список из 128 имен, и вы ищете в нем значение методом бинарного поиска. Какое максимальное количество проверок для этого может потребоваться?
Решение 
Так как бинарный поис с каждым разом сокрощяет поис в половину что бы найти О большое используем О(Log n) получим максимальное количество проверок 7.

1.2 Предположим, размер списка увеличился вдвое. Как изменится максимальное количество проверок?
Решение 

Увеличиваем список в двое получаем 256 используем О(Log n) получим максимальное количество проверок 8.

1.3 Известна фамилия, нужно найти номер в телефонной книге.
Решение: хорошо подойдет поиск O(log п) при условии что телефоная книга отсартирована.

1.4 Известен номер, нужно найти фамилию в телефонной книге. (Подсказка: вам придется провести поиск по всей книге!)

Решение: придеться использовать О(n) линейное время. Пройтись по всей книге несколько раз туда обратно пока не совпадут намера . Для примера если у нас телефоная книга из 10 намеров то как минимум берем в расчет код страны (Будет совподать у всех контактов ) + код оператора (На этом этапе начнеться отсеивать лишнее)+n шагов номера телефона пока не останиться один контакт.

1.5 Нужно прочитать телефоны всех людей в телефонной книге.
Решение :  использовать О(n) линейное время.  n будет зависить от количества контактов к телюкниге


Упражнения Глава 2. Сортировка выбором.

2.1 Допустим, вы строите приложение для управления финансами.
	1. Продукты
	2. Кино
	3. Вело КЛУБ
Ежедневно вы записываете все свои траты. В конце месяца вы анализируете расходы и вычисляете, сколько денег было потрачено. При
работе с данными выполняется множество операций вставки и относительно немного операций чтения. Какую структуру использовать -
массив или список?
Решение. Предпочтительней список так как операций чтений у нас меньше чем операций вставок.Используем обазночения 		
	О(n) =Ленейное время
	О(1)= Постояное время
Для чтения массива О(1) для списка О(n)
Для вставки в массив О(n) для списка О(1)
Из этого делаем вывод что при работе со вставками множество операций лечше подойдет список по затрате времени работы и памятию

2.2 Допустим, вы пишете приложение для приема заказов от посетителей
ресторана. Приложение должно хранить список заказов. Официанты
добавляют заказы в список, а повара читают заказы из списка и выполняют их. Заказы образуют очередь: официанты добавляют заказы
в конец очереди, а повар берет первый заказ из очереди и начинает
готовить.Какую структуру данных вы бы использовали для реализации этой
очереди: массив или связанный список? 
Решение. Я бы использовал список так как список болье быстрее реализует фун-ию добавления/удаления. Но только при условии что не надо читать список в произвольном порядке.

2.3 Проведем мысленный эксперимент. Допустим, Facebook хранит
список имен пользователей. Когда кто-то пытается зайти на сайт
Facebook, система пытается найти имя пользователя. Если имя входит
в список имен зарегистрированных пользователей, то вход разрешается. Пользователи приходят на Facebook достаточно часто, поэтому
поиск по списку имен пользователей будет выполняться часто . Будем
считать, что Facebook использует бинарный поиск для поиска в списке. Бинарному поиску необходим произвольный доступ - алгоритм
должен мгновенно обратиться к среднему элементу текущей части
списка. Зная это обстоятельство, как бы вы реализовали список пользователей: в виде массива или в виде связанного списка? 
Решение. Для бинарного поиска я бы использовал бы массив так как время чтения массива О(1). быстрее чем у списка.

2.4 Пользователи также довольно часто создают новые учетные записи на
Facebook. Предположим, вы решили использовать массив для хранения списка пользователей. Какими недостатками обладает массив для
выполнения вставки? Допустим, вы используете бинарный поиск для
нахождения учетных данных. Что произойдет при добавлении новых
пользователей в массив?
Решение. Придеться искать свободное место в памяти для расшерения масива и сдвигать ячейки памяти.Если возникнет ситуация с тем что в памяти не окажеться свободного места предеться переносить весь массив.

2.5 В действительности Facebook не использует ни массив, ни связанный
список для хранения информации о пользователях. Рассмотрим гибридную структуру данных: массив связанных списков. Имеется массив из 26 элементов. Каждый элемент содержит ссылку на связанный
список. Например, первый элемент массива указывает на связанный
список всех имен пользователей, начинающихся на букву «А». Второй
элемент указывает на связанный список всех имен пользователей, начинающихся на букву «В», и т. д.
Предположим, пользователь с именем 4:Adit в~ регистрируется на
Facebook и вы хотите добавить его в список. Вы обращаетесь к элементу 1 массива, находите связанный список элемента 1 и добавляете
«Adit в~ в конец списка. Теперь предположим, что зарегистрировать
нужно пользователя 4:Zakhir н~. Вы обращаетесь к элементу 26, ко ­
торый содержит связанный список всех имен, начинающихся с «Z~,
и проверяете, присутствует ли 4:Zakhir н~ в этом списке.
Теперь сравните эту гибридную структуру данных с массивами и связанными списками. Будет ли она быстрее или медленнее каждой исходной структуры при поиске и вставке? Приводить 4:0-большое~ не
нужно, просто выберите одно из двух: быстрее или медленнее.
Решение. Будет быстрее так как 1. этапом мы провидем поиск в массиве О(1). И дабавим новую ячейку имени с сылаясь на ее в последней ячейке списка. Здесь реализуеться чтение  по массиву О(1) и вставке по списку О(1).


